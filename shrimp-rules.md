# 개발 규칙

이 문서는 AI Agent가 `mcp-shrimp-task-manager` 프로젝트에서 개발 작업을 수행할 때 사용하는 전용 규칙입니다.

## 1. 프로젝트 개요

- **프로젝트 이름**: `mcp-shrimp-task-manager`
- **목적**: AI Agent를 위해 설계된 작업 관리 도구로, 사고 과정, 반성, 스타일 일관성을 강조합니다. 자연어를 구조화된 개발 작업으로 변환하며, 의존성 추적과 반복 최적화 기능을 갖추고 있습니다.
- **기술 스택**:
  - 주요 언어: TypeScript
  - 실행 환경: Node.js (ES Module)
  - 주요 프레임워크/라이브러리: Express.js (API 또는 WebGUI용), Zod (데이터 검증용)
  - 패키지 관리자: npm
- **핵심 기능**:
  - 자연어 작업 파싱
  - 구조화된 작업 생성 및 관리
  - 작업 의존 관계 추적
  - 작업 실행 및 검증 지원
  - AI Agent의 사고 흐름과 통합

## 2. 프로젝트 아키텍처

- **주요 소스 코드 디렉토리**: `src/`
  - `src/index.ts`: 주요 애플리케이션 진입점 또는 모듈 내보내기 지점. **이 파일 수정 시 영향 범위를 신중히 평가해야 합니다.**
  - `src/utils/`: 공통 유틸리티 함수.
  - `src/types/`: TypeScript 타입 정의. **새로운 타입 추가 또는 수정 시, Zod schema(해당하는 경우)와의 일관성을 반드시 보장해야 합니다.**
  - `src/tools/`: 프로젝트 특정 도구 또는 외부 서비스 통합 모듈.
  - `src/models/`: 데이터 모델 정의 (Zod schemas와 관련될 수 있음).
  - `src/prompts/`: AI 상호작용 관련 프롬프트 템플릿. **프롬프트 수정 또는 추가 시, AI Agent 행동에 대한 잠재적 영향을 고려해야 합니다.**
  - `src/public/`: WebGUI 또는 기타 정적 리소스.
  - `src/tests/`: 단위 테스트 및 통합 테스트.
- **컴파일 출력 디렉토리**: `dist/` (이 디렉토리는 `tsc`에 의해 자동 생성되며, **이 디렉토리 내용을 수동으로 수정하는 것을 금지합니다**).
- **설정 파일**:
  - `package.json`: 프로젝트 의존성 및 스크립트. **새로운 의존성 추가 후, 반드시 `npm install`을 실행해야 합니다.**
  - `tsconfig.json`: TypeScript 컴파일 설정. **필요하지 않은 경우, `"strict": true` 설정 수정을 금지합니다.**
  - `.env.example` & `.env`: 환경 변수 설정. **민감한 정보는 버전 관리에 커밋하지 마세요.**
- **문서**:
  - `README.md`: 주요 프로젝트 설명 문서.
  - `docs/`: 더 상세한 아키텍처, API 문서 등을 포함할 수 있음.
  - `CHANGELOG.md`: 버전 변경 기록. **새 버전 릴리스 전에 반드시 업데이트해야 합니다.**
  - `data/WebGUI.md`: Task Manager UI 링크를 포함.

## 3. 코드 규칙

### 3.1. 명명 규칙

- **변수와 함수**: 소문자 카멜 케이스(camelCase) 사용.
  - _예시 (가능)_: `const taskName = "example"; function processTask() {}`
  - _예시 (불가능)_: `const Task_Name = "example"; function Process_Task() {}`
- **클래스와 인터페이스**: 대문자 카멜 케이스(PascalCase) 사용.
  - _예시 (가능)_: `class TaskManager {}; interface ITaskOptions {}`
  - _예시 (불가능)_: `class taskManager {}; interface iTaskOptions {}`
- **파일 이름**: 소문자 카멜 케이스 또는 하이픈 연결(kebab-case)의 `.ts` 파일 사용.
  - _예시 (가능)_: `taskProcessor.ts`, `task-utils.ts`
  - _예시 (불가능)_: `TaskProcessor.ts`, `task_utils.ts`
- **상수**: 대문자 스네이크 케이스(UPPER_SNAKE_CASE) 사용.
  - _예시 (가능)_: `const MAX_RETRIES = 3;`
  - _예시 (불가능)_: `const maxRetries = 3;`

### 3.2. 형식 요구사항

- **들여쓰기**: 2개 공백으로 들여쓰기. **탭 문자 사용 금지.**
- **세미콜론**: 모든 문장 끝에 세미콜론 필수.
- **따옴표**: 문자열은 우선적으로 작은따옴표(`'`) 사용, 단 문자열 자체에 작은따옴표가 포함된 경우 제외.
  - _예시 (가능)_: `const message = 'Hello World'; const complex = "It\\'s complex";`
  - _예시 (불가능)_: `const message = "Hello World";`
- **최대 줄 길이**: 120자 이하 권장.
- **주석**:
  - 한 줄 주석은 `//` 사용.
  - 여러 줄 주석은 `/* ... */` 사용.
  - JSDoc 스타일 주석은 공개 함수, 클래스, 메서드에 적용.
    - _예시 (가능)_:
      ```typescript
      /**
       * 주어진 작업을 처리합니다.
       * @param taskId 처리할 작업의 ID.
       * @returns 성공 시 true, 실패 시 false.
       */
      function processTaskById(taskId: string): boolean {
        // 구현
        return true;
      }
      ```

### 3.3. TypeScript 특정 규칙

- **타입 주석**: 모든 함수 매개변수, 반환값, 변수 선언에 명확한 타입 주석이 있어야 함. **`any` 타입 사용 금지, 극히 특별하고 피할 수 없는 경우에만 사용하고 주석으로 이유를 설명해야 함.**
  - _예시 (가능)_: `function greet(name: string): string { return \`Hello, ${name}\`; }`
  - _예시 (불가능)_: `function greet(name): any { return "Hello, " + name; }`
- **인터페이스와 타입 별칭**: 객체의 형태를 정의할 때는 인터페이스(Interface)를 우선 사용하고, 유니온 타입, 튜플 또는 기타 복잡한 타입을 정의할 때는 타입 별칭(Type Alias) 사용.
- **ES Module**: `import`와 `export` 구문 사용.
  - _예시 (가능)_: `import { Task } from './models/task'; export class TaskService {}`
  - _예시 (불가능)_: `const Task = require('./models/task'); module.exports = TaskService;`
- **엄격 모드**: 프로젝트에서 `"strict": true`가 활성화됨. 모든 TypeScript 엄격 모드 오류를 해결해야 함.

## 4. 기능 구현 규칙

### 4.1. 공통 원칙

- **단일 책임 원칙 (SRP)**: 각 함수와 클래스는 하나의 기능만 담당해야 함.
- **간단함 유지 (KISS)**: 과도하게 복잡한 해결책 피하기.
- **재사용**: 가능한 한 공통 로직을 재사용 가능한 함수나 클래스로 추출하여 `src/utils/` 또는 관련 모듈에 저장.
- **오류 처리**:
  - 예상되는 오류는 `try...catch`로 처리.
  - 중요한 작업의 경우 명확한 오류 메시지 제공.
  - 더 풍부한 오류 정보를 제공하기 위해 사용자 정의 오류 클래스 사용 고려.
- **로그 기록**:
  - 중요한 작업, 오류 처리, 중요한 상태 변경 시 로그 기록 추가.
  - 구조화된 로그 사용 고려.
  - **로그에 민감한 정보(비밀번호, API 키 등) 기록 금지.**

### 4.2. Zod 사용

- `src/models/` 또는 `src/types/`에 위치한 데이터 구조 정의는 우선적으로 Zod schema를 사용하여 정의하고 검증해야 함.
- Zod schema는 TypeScript 타입과 동기화되어야 함. `z.infer<typeof schema>`를 사용하여 타입 생성 가능.

  - _예시 (가능)_:

    ```typescript
    import { z } from "zod";

    export const TaskSchema = z.object({
      id: z.string().uuid(),
      name: z.string().min(1),
      description: z.string().optional(),
    });

    export type Task = z.infer<typeof TaskSchema>;
    ```

### 4.3. Express.js 사용 (API/WebGUI가 있는 경우)

- 라우트 정의는 명확하고 RESTful 원칙을 따름 (API인 경우).
- 미들웨어(Middleware)는 효과적으로 구성, 예를 들어 오류 처리 미들웨어, 로그 미들웨어 등.
- 모든 외부 입력(request parameters, body, query)은 **반드시** Zod 또는 유사한 메커니즘으로 검증해야 함.

## 5. 프레임워크/플러그인/서드파티 라이브러리 사용 규칙

- **새로운 의존성 추가**:
  - **반드시** 먼저 의존성의 필요성, 유지보수 상태, 보안성을 평가.
  - `npm install <package-name>` (실행 의존성용) 또는 `npm install --save-dev <package-name>` (개발 의존성용) 사용.
  - **반드시** `package.json`에서 명확한 버전 범위 지정 (예: `^1.2.3` 또는 `~1.2.3`), `*` 사용 금지.
- **의존성 업데이트**: 정기적으로 의존성을 최신 안정 버전으로 확인하고 업데이트하여 보안 패치와 새 기능을 얻음. 업데이트 전 잠재적 호환성 손상 변경사항 평가.
- **의존성 제거**: 더 이상 필요하지 않은 의존성은 `npm uninstall <package-name>`으로 제거하고 코드에서 관련 참조 제거.

## 6. 워크플로우 규칙

### 6.1. 개발 프로세스

1.  **작업 이해**: 작업 설명, 요구사항, 수락 기준을 주의 깊게 읽기.
2.  **브랜치 관리**: 최신 `main` (또는 `develop`) 브랜치에서 새로운 기능 브랜치(feature branch) 생성. 브랜치 이름은 간결하고 명확해야 함, 예: `feature/add-task-editing` 또는 `fix/login-bug`.
3.  **코딩과 테스트**:
    - 이 규칙에 따라 코딩.
    - **반드시** 새 기능이나 수정된 버그에 대해 단위 테스트 작성 (`src/tests/`에 저장).
    - `npm run build` 실행하여 코드가 성공적으로 컴파일되는지 확인.
    - 로컬에서 `npm run dev` 또는 `npm run start` 실행하여 테스트.
4.  **코드 커밋**:
    - Git commit message는 Conventional Commits 규칙을 따름 (예: `feat: add user authentication`, `fix: resolve issue with task sorting`).
    - **주요 브랜치에 `console.log` 또는 기타 디버그 메시지가 포함된 코드 커밋 금지.**
5.  **Pull Request (PR)**:
    - 기능 브랜치를 원격 저장소에 푸시하고 `main` (또는 `develop`) 브랜치로 Pull Request 생성.
    - PR 설명은 변경 내용과 이유를 명확히 설명.
6.  **Code Review**: 다른 개발자나 AI Agent의 Code Review 대기.
7.  **병합과 배포**: Code Review 통과 후 PR 병합. 배포 프로세스는 프로젝트 설정에 따름.

### 6.2. 버전 관리 (Git)

- **주요 브랜치**:
  - `main`: 안정적이고 배포 가능한 제품 버전을 나타냄.
  - `develop` (사용하는 경우): 개발 중인 최신 버전을 나타냄.
- **커밋 빈도**: 작은 단계로 빠르게 진행하고 의미 있는 변경사항을 자주 커밋하는 것을 권장.
- **충돌 해결**: 브랜치 병합 또는 rebase 시 충돌이 발생하면 **반드시** 신중하게 해결하여 코드의 정확성과 완전성 보장.

### 6.3. CHANGELOG 업데이트

- 새 버전 릴리스 전에 **반드시** `CHANGELOG.md` 업데이트.
- 기록에는 버전 번호, 릴리스 날짜, 새 기능, 수정된 버그, 주요 변경사항 목록 포함.

## 7. 주요 파일 상호작용 규칙

- **`src/types/` 또는 `src/models/` 수정 (특히 Zod schemas)**:
  - **반드시** 이러한 타입이나 schema를 참조하는 모든 파일을 확인하고 업데이트하여 타입 일관성 보장.
  - **반드시** 관련 테스트 재실행.
- **`src/index.ts` 수정**:
  - 모듈의 내보내기 API를 수정한 경우, **반드시** 이 모듈에 의존하는 모든 프로젝트나 파일을 확인하고 적절히 조정.
- **`package.json` 수정 (특히 `dependencies` 또는 `scripts`)**:
  - **반드시** 팀 멤버나 관련 AI Agent에게 `npm install` 실행을 알림.
  - `scripts` 수정 시 CI/CD 프로세스(있는 경우)도 적절히 업데이트되어야 함.
- **`.env.example` 수정**:
  - **반드시** 모든 개발 환경의 `.env` 파일을 동기화하고 팀 멤버에게 알림.
- **`README.md` 또는 `docs/` 내 문서 수정**:
  - 핵심 기능이나 사용 방법에 관련된 변경사항인 경우, **반드시** 문서 내용의 정확성과 최신성 보장.

## 8. AI 결정 규칙

### 8.1. 모호한 요청 처리

- 모호한 개발 지시를 받았을 때 (예: "작업 목록 표시 최적화"):
  1.  **명확화 시도**: 가능한 경우 사용자나 작업 발기자에게 더 구체적인 세부사항이나 예상 결과 요청.
  2.  **컨텍스트 분석**: 관련 코드(`src/`), 기존 UI(있는 경우), 관련 이슈(있는 경우)를 확인하여 가능한 의도 추론.
  3.  **방안 제시**: 분석을 바탕으로 1-2개의 구체적인 구현 방안을 제시하고 각각의 장단점과 예상 작업량 설명.
  4.  **확인 대기**: 명확한 지시를 받기 전까지 대규모 코드 수정 금지.

### 8.2. 오류/예외 처리 전략

- **우선순위**:
  1.  **사용자 경험**: 프로그램 크래시 방지, 친화적인 오류 메시지 제공.
  2.  **데이터 무결성**: 오류가 데이터 손상이나 불일치를 야기하지 않도록 보장.
  3.  **시스템 안정성**: 상세한 오류 정보 기록하여 문제 해결에 활용.
- **선택**:
  - 예상 가능한 오류(예: 사용자 입력 무효)의 경우 해당 작업의 컨텍스트에서 처리하고 메시지 제공.
  - 예상치 못한 시스템 오류의 경우 포착, 기록하고 필요시 상위로 던지거나 전역 오류 처리 메커니즘 트리거.

### 8.3. 의존성 선택

- 새로운 서드파티 라이브러리 도입이 필요할 때:
  1.  **기존 확인**: 프로젝트에 요구사항을 충족하는 유사한 라이브러리가 이미 있는지 확인.
  2.  **옵션 평가**:
      - **활성도와 커뮤니티 지원**: 잘 유지보수되고 활발한 커뮤니티를 가진 라이브러리 선택.
      - **경량**: 과도하게 크거나 기능이 중복되는 라이브러리 도입 금지.
      - **보안**: 알려진 보안 취약점이 있는지 확인.
      - **라이선스**: 프로젝트 라이선스와 호환되는지 확인.
  3.  **최소화 원칙**: 정말 필요한 라이브러리만 도입.

## 9. 금지 사항

- **`dist/` 디렉토리 내 모든 파일 직접 수정 금지.** 이 디렉토리는 컴파일 결과물.
- **`npm install` 실행 없이 새 의존성을 사용할 수 있다고 가정 금지.**
- **주요 브랜치(`main` 또는 `develop`)에 테스트되지 않았거나 완료되지 않은 코드 직접 커밋 금지.** 반드시 기능 브랜치 사용.
- **API 키, 비밀번호 또는 기타 민감한 정보가 포함된 코드를 버전 관리 시스템에 커밋 금지.** `.env` 파일을 사용하여 이러한 정보 관리.
- **알리거나 동의 없이 핵심 아키텍처나 공개 API를 대폭 수정 금지.**
- **TypeScript 타입 오류 무시 금지.** 모든 `tsc`가 보고하는 오류를 해결해야 함.
- **충분한 이유와 주석 없이 `any` 타입 사용 금지.**
- **코드에 대량의 `console.log` 또는 기타 임시 디버그 코드 남기기 금지.**
- **`CHANGELOG.md` 업데이트 없이 새 버전 릴리스 금지.**
- **프로젝트 MIT 라이선스와 호환되지 않는 서드파티 라이브러리 도입 금지.**

## 10. 이 규칙 문서(`shrimp-rules.md`) 업데이트

- 프로젝트의 기술 스택, 핵심 아키텍처, 주요 워크플로우 또는 중요한 규칙이 변경될 때 **반드시** 이 파일을 동기화하여 업데이트.
- 업데이트 요청은 변경이 필요한 섹션과 내용을 명확히 지적해야 함.
- 모호한 "규칙 업데이트" 지시를 받았을 때 AI Agent는 **반드시**:
  1.  현재 코드베이스의 변경사항을 자율적으로 분석 (예: `git diff`, 최근 commit).
  2.  기존 `shrimp-rules.md`와 프로젝트 현황을 비교하여 일치하지 않거나 오래된 규칙 찾기.
  3.  `process_thought` 단계에서 추론된 업데이트 지점과 그 이유 나열.
  4.  구체적인 수정 제안을 제시하거나 이 파일을 직접 편집.
  5.  **자율 분석 실행 전에 모호한 요청으로 사용자에게 명확화를 요청하는 것을 엄격히 금지.**

---

이 개발 규칙은 AI Agent가 `mcp-shrimp-task-manager` 프로젝트 개발에 효율적이고 일관되며 안전하게 참여할 수 있도록 보장하기 위한 것입니다.
