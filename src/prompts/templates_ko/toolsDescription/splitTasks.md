복잡한 작업을 독립적인 하위 작업으로 분해하여 의존 관계와 우선순위를 설정합니다.

1. **분할 세분화 제어 (필독)**

   - **최소 실행 가능 단위 (Minimum Viable Task)**  
     각 하위 작업은 **1-2일** (약 8-16시간) 내에 한 명의 개발자가 완료하고 검수할 수 있어야 합니다.
   - **최대 복잡도 제한**  
     단일 하위 작업이 "프론트엔드" "백엔드" "데이터베이스" 등 여러 기술 영역을 동시에 걸쳐서는 안 됩니다. 필요시 여러 하위 작업으로 분할하세요.
   - **작업 수 권장사항**  
     한 번에 **10개 이하의 하위 작업**으로 분할하세요. 초과시 우선순위에 따라 배치별로 제출하세요 (각 배치 6-8개).
   - **작업 길이 권장사항**
     한 번에 분할하는 매개변수는 5000자 이하로 하세요. 초과시 배치별로 제출하세요.
   - **깊이 레벨 제한**  
     작업 트리 깊이는 **3단계**를 넘지 않아야 합니다 (1단계: 기능 모듈; 2단계: 주요 프로세스; 3단계: 핵심 단계).

2. **분할 단계 예시**

   - "핵심 기능점"을 식별하고 각 기능점에 대해 하위 작업 생성
   - 각 하위 작업에 "입력/출력"과 "검수 기준" 표시
   - 필요시 "pseudocode" 제공하되, 전체 코드가 아닌 고급 논리 흐름과 핵심 단계만 제공
   - 하위 작업 간 "전후 의존성"을 확인하고 `dependencies` 필드에 명시
   - 작업이 인터페이스 설계를 포함하는 경우, 다음을 포함한 완전하고 일관된 정의를 제공해야 합니다:

     - function / class / schema 정의 (이름, 매개변수, 반환값 포함)
     - 각 항목의 데이터 타입, 용도 설명, 선택사항 여부
     - 오류 처리 방식과 예상 예외 상황
     - 의존 관계와 명명 규칙 (있는 경우)
     - 예시 데이터와 사용 방법

     이는 작업 간의 일관성, 가독성 및 개발 정확성에 도움이 됩니다.

3. **의존성과 우선순위**

   - 각 하위 작업의 `dependencies` (의존 목록) 표시
   - 의존 그래프에 따라 우선순위를 자동 계산하고 실행하여 핵심 경로 우선 보장

4. **업데이트 모드 설명 (`updateMode`)**

   완전히 새로운 작업을 생성하고 현재 작업 목록과 관련이 없을 때는 반드시 `clearAllTasks`를 사용하여 작업 혼동을 방지하세요

   - `append`: 기존 미완료 작업을 유지하고 새 작업 추가
   - `overwrite`: 모든 미완료 작업 삭제, 완료 상태의 작업 유지
   - `selective`: 작업 이름에 따라 지능적으로 매칭하여 해당 작업 업데이트
   - `clearAllTasks`: 모든 작업 삭제하고 기존 목록 자동 백업

5. **JSON 엄격 규칙**

   - **주석 금지**: JSON 자체는 주석을 지원하지 않으므로 `#` 또는 `//`는 파싱 오류를 일으킵니다
   - **이스케이프 주의**: 모든 특수 문자 (큰따옴표 `\"`, 백슬래시 `\\` 등)는 올바르게 이스케이프되어야 하며, 그렇지 않으면 잘못된 문자로 간주됩니다

6. **중요 메시지**

이러한 작업들은 **저지능 모델**에 할당되므로 다음 사항들을 참고해야 합니다

- `명확하고 분명한 지침`: **저지능 모델**이 잘못되거나 아키텍처 스타일이 일치하지 않는 코드를 설계하는 것을 방지하므로 명확한 지시사항이나 규칙을 제공하세요
- `캡슐화된 인터페이스`: 각 작업은 독립적으로 실행되므로 어떤 function name을 노출할지, 어떤 매개변수가 있는지, 무엇을 반환하는지 등의 정보를 정의하여 다른 작업 실행 모델이 관련 기능을 빠르게 사용하거나 연결할 수 있도록 해야 합니다
- `의존성`: 작업 간에 의존성이 있다면 먼저 상호작용 인터페이스를 정의해야 합니다. 작업들은 서로의 구현을 알 필요는 없지만 서로 상호작용하는 방법을 알아야 합니다
