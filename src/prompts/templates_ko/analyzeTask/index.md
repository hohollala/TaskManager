## 코드베이스 분석

초기 솔루션을 받은 후, 다음 검토 및 최적화를 순서대로 완료하고 마지막에 `reflect_task` 도구를 호출하십시오:

1. **구조적 무결성 검사**

   - 모든 요구 사항과 제약 조건을 포함합니까?
   - 모듈 경계 및 인터페이스 정의가 명확합니까?
   - 종속성 그래프가 합리적이고 유지 보수 가능합니까?
   - 설계가 프로젝트의 핵심 아키텍처 패턴을 따릅니까?
   - 프로젝트의 기존 계층 구조 및 구성 요소 분할이 유지되었습니까?

2. **중복 기능 감지 및 공유 판단**

   - 정확한 검색 전략 사용:
     - `codebase_search`, `read_file` 또는 기타 유사 도구를 사용하여 유사한 기능 구현 검색
     - 핵심 구성 요소 및 유틸리티 클래스의 목적과 책임을 분석
   - 솔루션의 기능이 기존 코드 또는 다른 모듈과 중복되는지 확인
   - 중복되는 경우 판단:
     - 기존 구성 요소를 직접 **재사용**할 수 있습니까? (적용 가능성, 확장성 평가)
     - 또는 공유 구성 요소로 **리팩토링/추상화**해야 합니까? (재사용 비용 및 이점 고려)
   - 재사용 결정의 이유와 영향 범위를 명확하게 표시

3. **성능 및 확장성 평가**

   - 잠재적인 성능 병목 현상이 있습니까?
   - 미래의 새로운 요구 사항에 대한 설계의 확장성은 어떻습니까?
   - 리소스 사용 및 시스템 부하를 고려했습니까?
   - 확장 전략이 프로젝트의 기존 패턴을 따릅니까?

4. **일관성 및 스타일 검증**

   - 프로젝트의 기존 코드 스타일, 명명 및 아키텍처 규칙을 따릅니까?
     - 명명 규칙(카멜 케이스, 스네이크 케이스 등) 일관성 확인
     - 메서드/함수 매개변수 및 반환 값 스타일 확인
     - 주석 및 문서 형식 확인
   - 프로젝트 고유의 디자인 패턴 및 아키텍처 결정을 따릅니까?
   - 팀의 모범 사례를 위반한 것이 있습니까?
   - UI/UX 디자인이 현재 화면 스타일과 일치합니까?

5. **아키텍처 통합 평가**

   - 새 기능이 기존 아키텍처와 원활하게 통합되는 방법
   - 기존 모듈 및 서비스에 미치는 영향 평가
   - 하위 호환성 유지 확인
   - 시스템 경계 및 모듈 캡슐화 보호 확인

6. **최적화 제안**
   - 위 검토를 기반으로 최적화된 답변 정리
   - 제안이 기존 아키텍처와 일치하는지 확인
   - 구체적인 코드 구성 및 통합 전략 제공
   - 도구 호출:
     ```
     reflect_task({ summary: '분석 요약', analysis: <분석 결과> })
     ```

**이제 `reflect_task`를 호출하십시오. 도구를 호출하지 않는 것은 엄격히 금지됩니다.**
